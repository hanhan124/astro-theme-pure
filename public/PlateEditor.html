<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PlateEditor</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§¬</text></svg>">
  <style>
    :root {
      --primary: #4285F4;
      --primary-dark: #3367D6;
      --secondary: #9AA0A6;
      --success: #34A853;
      --warning: #FBBC05;
      --danger: #EA4335;
      --surface: #FFFFFF;
      --surface-alt: #F8F9FA;
      --border: #DADCE0;
      --text-primary: #3C4043;
      --text-secondary: #5F6368;
      --text-muted: #80868B;
      --shadow-sm: 0 1px 2px rgba(60,64,67,0.3);
      --shadow-md: 0 2px 6px rgba(60,64,67,0.15);
      --shadow-lg: 0 4px 12px rgba(60,64,67,0.15);
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --blur-bg: rgba(255,255,255,0.95);
    }
    
    body { 
      font-family: 'Roboto', 'Noto Sans SC', 'Microsoft YaHei', sans-serif; 
      background: linear-gradient(135deg, #F1F3F4 0%, #E8EAED 100%); 
      margin: 0; 
      color: var(--text-primary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
    }
    
    .container { 
      display: flex; 
      gap: 0; 
      height: 100vh; 
      max-height: 100vh;
      background: var(--surface);
      border-radius: var(--radius-lg);
      margin: 8px;
      box-shadow: var(--shadow-lg);
      overflow: hidden;
    }
    
    .left { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      background: var(--surface);
      border-radius: var(--radius-lg) 0 0 var(--radius-lg);
      border-right: 1px solid var(--border);
    }
    
    .stage-wrap { 
      flex: 1; 
      position: relative; 
      overflow: hidden; 
      background: var(--surface); 
      border-right: 1px solid var(--border);
    }
    
    .stage { 
      position: absolute; 
      left: 0; 
      top: 0; 
      transform-origin: 0 0; 
    }
    
    .grid-container { 
      padding: 20px; 
      background: var(--surface);
    }
    
    #grid { 
      border-collapse: separate; 
      border-spacing: 1px;
      background: var(--surface); 
      box-shadow: var(--shadow-md);
      border-radius: var(--radius-md);
      overflow: hidden;
      border: 1px solid var(--border);
    }
    
    #grid th, #grid td { 
      border: 1px solid var(--border);
      width: 38px; 
      height: 38px; 
      text-align: center; 
      vertical-align: middle; 
      font-size: 11px; 
      line-height: 1.2; 
      transition: all 0.15s ease;
      background: var(--surface);
    }
    
    #grid th { 
      background: linear-gradient(135deg, #F8F9FA 0%, #E8EAED 100%); 
      font-weight: 600; 
      cursor: pointer; 
      user-select: none; 
      color: var(--text-primary); 
      position: sticky; 
      z-index: 1; 
      border-bottom: 2px solid var(--border);
      font-size: 10px;
      letter-spacing: 0.3px;
    }
    
    #grid th:hover {
      background: linear-gradient(135deg, #E8F0FE 0%, #D2E3FC 100%);
      transform: translateY(-1px);
      box-shadow: 0 1px 4px rgba(26,115,232,0.2);
    }
    
    #grid td { 
      cursor: pointer; 
      background: var(--surface); 
      position: relative;
    }
    
    #grid td:hover {
      background: #F8F9FA;
      transform: scale(1.02);
      z-index: 2;
      box-shadow: 0 2px 8px rgba(26,115,232,0.15);
      border-color: var(--primary);
    }
    
    #grid td.selected { 
      outline: 2px solid var(--primary); 
      outline-offset: -1px; 
      background: rgba(26,115,232,0.08);
      box-shadow: 0 0 0 1px var(--primary) inset;
      position: relative;
      z-index: 10;
      border-color: var(--primary);
    }
    
    #grid td.selected::before {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      border: 2px solid var(--primary);
      border-radius: 2px;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    
    #grid td.only-sample { 
      background: linear-gradient(135deg, #FFF9C4 0%, #FFF59D 100%); 
      color: #2D3748; 
      font-weight: 500;
      border: 1px solid #FFEB3B;
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.8);
    }
    
    #grid td.only-gene { 
      background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%); 
      color: #2D3748; 
      font-weight: 500;
      border: 1px solid #90CAF9;
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.8);
    }
    
    #grid td.both-values { 
      background: linear-gradient(135deg, #E8F5E8 0%, #C8E6C9 100%); 
      color: #2D3748; 
      font-weight: 500;
      border: 1px solid #A5D6A7;
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.8);
    }
    
    .value-text { 
      display: inline-block; 
      padding: 2px 4px; 
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 4px; 
      margin: 1px 0; 
      font-weight: 500;
      box-shadow: 0 1px 1px rgba(0,0,0,0.05);
      font-size: 10px;
    }
    
    .target-gene { 
      font-style: italic; 
      font-weight: 500;
    }
    
    .toolbar { 
      padding: 12px 20px; 
      border-top: 1px solid var(--border); 
      background: var(--surface);
      display: flex; 
      align-items: center; 
      gap: 12px; 
      min-height: 52px;
    }
    
    .right { 
      width: 300px; 
      background: var(--surface);
      border-left: 1px solid var(--border); 
      display: flex; 
      flex-direction: column; 
      border-radius: 0 var(--radius-lg) var(--radius-lg) 0;
      box-shadow: -1px 0 8px rgba(60,64,67,0.1);
      /* å…è®¸ä¾§æ å‡ºç°æ»šåŠ¨ï¼Œè€Œä¸æ˜¯è£åˆ‡å†…å®¹ */
      overflow: auto;
      flex-shrink: 0;
    }
    
    .sidebar { 
      padding: 16px; 
      overflow-y: auto;  /* æ·»åŠ å‚ç›´æ»šåŠ¨ */
      overflow-x: hidden; /* é˜²æ­¢æ°´å¹³æ»šåŠ¨ */
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: calc(100vh - 32px);
      box-sizing: border-box;
    }
    
    .sidebar h2 { 
      margin: 0; 
      font-size: 14px; 
      font-weight: 600; 
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 0 4px 0;
      border-bottom: 1px solid var(--border);
      letter-spacing: 0.2px;
    }
    
    .sidebar h2::before {
      content: "ğŸ§¬";
      font-size: 16px;
    }
    
    .form-row { 
      margin-bottom: 0; 
      padding: 6px 0;
      border-bottom: 1px solid var(--surface-alt);
    }
    
    .form-row label { 
      display: block; 
      font-size: 11px; 
      color: var(--text-secondary);
      margin-bottom: 6px; 
      font-weight: 500;
      letter-spacing: 0.2px;
    }
    
    .form-row input, .form-row select { 
      width: 100%; 
      padding: 8px 12px; 
      border: 1px solid var(--border);
      border-radius: var(--radius-sm); 
      font-size: 13px; 
      background: var(--surface); 
      transition: all 0.15s ease;
      font-family: 'Roboto', 'Noto Sans SC', sans-serif;
      box-sizing: border-box;
    }
    
    .form-row input:focus, .form-row select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(26,115,232,0.1);
    }
    
    .form-row input::placeholder {
      color: var(--text-muted);
      opacity: 0.7;
    }
    
    .btn { 
      width: 100%; 
      padding: 10px 12px; 
      font-size: 13px; 
      font-weight: 600; 
      color: #ffffff;
      border: none; 
      border-radius: var(--radius-sm); 
      cursor: pointer; 
      margin-bottom: 6px; 
      transition: all 0.15s ease;
      position: relative;
      /* é¿å…æŒ‰é’®å†…éƒ¨å†…å®¹è¢«è£åˆ‡ */
      overflow: visible;
      letter-spacing: 0.2px;
    }
    
    .btn-large { 
      padding: 14px 16px; 
      font-size: 15px; 
      font-weight: 700;
      margin-bottom: 12px;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.3s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn-primary { 
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); 
      box-shadow: 0 2px 8px rgba(142,197,252,0.2);
    }
    
    .btn-gray { 
      background: linear-gradient(135deg, var(--secondary) 0%, #B0B0B5 100%); 
    }
    
    .btn-orange { 
      background: linear-gradient(135deg, var(--warning) 0%, #FFC085 100%); 
    }
    
    .btn-red { 
      background: linear-gradient(135deg, var(--danger) 0%, #FF8C94 100%); 
      box-shadow: 0 2px 8px rgba(255,179,186,0.2);
    }
    
    .btn-green { 
      background: linear-gradient(135deg, var(--success) 0%, #8CDBB5 100%); 
      box-shadow: 0 2px 8px rgba(168,230,207,0.2);
    }
    
    .btn:hover { 
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .small { 
      font-size: 11px; 
      color: var(--text-muted);
    }
    
    #grid td, #grid th {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    .compact-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
      margin-bottom: 6px;
    }
    
    .compact-grid .btn {
      margin-bottom: 0;
      padding: 6px;
      font-size: 11px;
    }
    
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: var(--text-muted);
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 0 1px var(--success);
      animation: pulse 2s ease-in-out infinite;
    }
    
    .sidebar::-webkit-scrollbar {
      width: 8px;
    }
    
    .sidebar::-webkit-scrollbar-track {
      background: var(--surface-alt);
      border-radius: 4px;
    }
    
    .sidebar::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    
    .sidebar::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }
    
    input[type="file"] {
      padding: 12px 16px;
      border: 2px dashed var(--border);
      border-radius: 12px;
      background: var(--surface-alt);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    input[type="file"]:hover {
      border-color: var(--primary);
      background: rgba(0, 122, 255, 0.05);
    }
    
    input[type="file"]::file-selector-button {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      background: var(--primary);
      color: white;
      font-weight: 600;
      cursor: pointer;
      margin-right: 12px;
      transition: all 0.2s ease;
    }
    
    input[type="file"]::file-selector-button:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }
  </style>
  <!-- SheetJS for xlsx export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- html2canvas for screenshot export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="left">
      <div class="stage-wrap" id="stageWrap" aria-label="Plate viewport">
        <div class="stage" id="stage" style="transform: translate(0px, 0px) scale(1);">
          <div class="grid-container">
            <table id="grid"></table>
          </div>
        </div>
      </div>
      <div class="toolbar">
        <div class="status-indicator">
          <div class="status-dot"></div>
          <span>Ready</span>
        </div>
        <input id="zoomRange" type="range" min="0.5" max="2" step="0.01" value="1" style="width:120px;" title="Zoom scale">
        <button id="resetView" class="btn btn-gray" style="width:auto; padding:8px 12px; font-size:12px;">Reset</button>
        <span class="small" id="viewStatus" style="margin-left:auto;">Scale:1.00</span>
      </div>
    </div>

    <div class="right">
      <div class="sidebar">
        <h1>ğŸ“‘ PlateEditor</h1>

        <div class="form-row">
          <label for="instrument">Instrument Type</label>
          <select id="instrument">
            <option value="biorad">Bio-Rad CFX384</option>
            <option value="roche">Roche LightCyclerÂ® 480</option>
          </select>
        </div>

        <h2 style="margin-top:20px; border-bottom: 1px solid var(--border); padding-bottom: 6px;">Data Import</h2>
        <div class="form-row">
          <label for="excelFile">Select Excel File (Auto Import)</label>
          <input type="file" id="excelFile" accept=".xlsx,.xls">
        </div>
        <div style="font-size: 11px; color: var(--text-muted); margin-top: -8px; margin-bottom: 12px;">
          Data will be automatically imported after file selection
        </div>


        <div class="form-row">
          <label for="targetGene">Target Gene</label>
          <input type="text" id="targetGene" placeholder="Enter gene name">
        </div>
          
        <div class="form-row">
          <label for="sampleName">Sample Name</label>
          <input type="text" id="sampleName" placeholder="Enter sample name">
        </div>

        <button class="btn btn-primary btn-large" id="applyBtn">Apply</button>

        <div class="compact-grid">
          <button class="btn btn-gray" id="removeSelBtn">Clear Selection</button>
          <button class="btn btn-gray" id="clearSampleBtn">Clear Sample</button>
          <button class="btn btn-gray" id="clearGeneBtn">Clear Gene</button>
          <button class="btn btn-gray" id="clearValuesBtn">Clear Values</button>
        </div>

        <button class="btn btn-red" id="resetAllBtn">Reset All Data</button>


        <h2 style="margin-top:20px; border-bottom: 1px solid var(--border); padding-bottom: 6px;">Data Export</h2>
        <div class="form-row">
          <label for="xlsxFileName">File Name</label>
          <input type="text" id="xlsxFileName" placeholder="Default timestamp">
        </div>
        <button class="btn btn-green btn-large" id="exportXLSXBtn">Export</button>
        <div style="text-align: center; margin-top: 8px; font-size: 10px; color: #80868B; font-style: normal;">
          Designed by FGH & Tecent Codebuddy
        </div>
      </div>
    </div>
  </div>

  <script>
    const rows = 16;
    const cols = 24;
    const rowLabels = Array.from({length: rows}, (_, i) => String.fromCharCode(65 + i)); // A..P
    const grid = document.getElementById('grid');

    // Selection state
    let isDragging = false;
    let startElement = null;
    let dragType = null; // 'cell','row','col'
    // Colors
    const colorPalette = [
      '#FF3B30','#FF9500','#FFCC00','#4CD964','#5AC8FA',
      '#007AFF','#5856D6','#FF2D55','#FF3B30','#FF9500',
      '#FFCC00','#4CD964','#5AC8FA','#007AFF','#5856D6',
      '#FF2D55','#8E8E93','#C7C7CC','#D1D1D6','#E5E5EA'
    ];
    const MAX_COLOR_MAP = 200;
    const sampleNameColors = new Map();
    const targetGeneColors = new Map();
    function getValueColor(value, type) {
      const map = type === 'sample' ? sampleNameColors : targetGeneColors;
      if (!value) return '#fff';
      if (!map.has(value)) {
        if (map.size >= MAX_COLOR_MAP) {
          const firstKey = map.keys().next().value;
          map.delete(firstKey);
        }
        const lightColors = [
          '#F8FBFF', '#F9F7FF', '#F7FFF7', '#FFFCF5', '#FFF5F8',
          '#F5FFFE', '#FDFFF7', '#FFFEF5', '#F7F8FF', '#F7FFF9',
          '#F5FEFF', '#F9F7FF', '#F7FFF7', '#FFFCF5', '#FFF5F8'
        ];
        const colorIndex = map.size % lightColors.length;
        map.set(value, lightColors[colorIndex]);
      }
      return map.get(value);
    }

    // Build grid
    function createGrid() {
      grid.innerHTML = '';
      let header = '<tr><th></th>';
      for (let c=1; c<=cols; c++) {
        header += `<th data-col="${c}" onmousedown="startDrag(this,'col')" onmouseover="dragSelect(this)" onmouseup="endDrag()">${c}</th>`;
      }
      header += '</tr>';
      grid.innerHTML += header;

      for (let r=0; r<rows; r++) {
        let rowHTML = `<tr><th data-row="${rowLabels[r]}" onmousedown="startDrag(this,'row')" onmouseover="dragSelect(this)" onmouseup="endDrag()">${rowLabels[r]}</th>`;
        for (let c=1; c<=cols; c++) {
          rowHTML += `<td data-row="${rowLabels[r]}" data-col="${c}" onmousedown="startDrag(this,'cell')" onmouseover="dragSelect(this)" onmouseup="endDrag()"></td>`;
        }
        rowHTML += '</tr>';
        grid.innerHTML += rowHTML;
      }
    }

    // Update cell display
    function updateCellAppearance(cell) {
      const sample = cell.dataset.sampleName || '';
      const gene = cell.dataset.targetGene || '';
      const ct = cell.dataset.ct || '';
      cell.classList.remove('only-sample','only-gene','both-values');

      let html = '';
      if (sample && gene) {
        cell.classList.add('both-values');
        html = `<span class="value-text" style="background:${getValueColor(sample,'sample')}">${sample}</span><br><span class="value-text target-gene" style="background:${getValueColor(gene,'gene')}">${gene}</span>`;
      } else if (sample) {
        cell.classList.add('only-sample');
        html = `<span class="value-text" style="background:${getValueColor(sample,'sample')}">${sample}</span>`;
      } else if (gene) {
        cell.classList.add('only-gene');
        html = `<span class="value-text target-gene" style="background:${getValueColor(gene,'gene')}">${gene}</span>`;
      }
      cell.innerHTML = html;
      const inst = document.getElementById('instrument').value;
      const ctLabel = inst === 'roche' ? 'Cp' : 'Cq';
      cell.title = `Pos ${cell.dataset.row}${cell.dataset.col} | Sample: ${sample || 'None'} | Gene: ${gene || 'None'} | ${ctLabel}: ${ct || 'NA'}`;
    }

    // Sidebar inputs sync
    function updateSidebarInputs() {
      const selected = document.querySelectorAll('#grid td.selected');
      const sampleInput = document.getElementById('sampleName');
      const geneInput = document.getElementById('targetGene');

      if (selected.length > 0) {
        const samples = Array.from(selected).map(td => td.dataset.sampleName || '');
        const genes = Array.from(selected).map(td => td.dataset.targetGene || '');
        const us = [...new Set(samples)];
        const ug = [...new Set(genes)];
        sampleInput.value = us.length === 1 ? us[0] : '';
        geneInput.value = ug.length === 1 ? ug[0] : '';
      } else {
        sampleInput.value = '';
        geneInput.value = '';
      }
    }

    // Selection helpers - æ— å»¶è¿Ÿæ¡†é€‰
    function clearSelections() {
      document.querySelectorAll('#grid td.selected').forEach(td => td.classList.remove('selected'));
    }
    
    window.startDrag = function(el, type) {
      isDragging = true;
      startElement = el;
      dragType = type;
      clearSelections();
      if (type === 'row') {
        const label = el.dataset.row;
        document.querySelectorAll(`td[data-row="${label}"]`).forEach(td => td.classList.add('selected'));
      } else if (type === 'col') {
        const col = parseInt(el.dataset.col);
        document.querySelectorAll(`td[data-col="${col}"]`).forEach(td => td.classList.add('selected'));
      } else if (type === 'cell') {
        el.classList.add('selected');
      }
      updateSidebarInputs();
    };
    
    window.dragSelect = function(el) {
      if (!isDragging) return;
      
      clearSelections();
      
      // ç›´æ¥æ‰§è¡Œï¼Œæ— å»¶è¿Ÿä¼˜åŒ–
      if (dragType === 'row' && el.dataset.row) {
        const s = rowLabels.indexOf(startElement.dataset.row);
        const e = rowLabels.indexOf(el.dataset.row);
        const min = Math.min(s,e), max = Math.max(s,e);
        // è¾¹ç•Œæ§åˆ¶ï¼šç¡®ä¿åœ¨æœ‰æ•ˆè¡ŒèŒƒå›´å†…
        const validMin = Math.max(0, min);
        const validMax = Math.min(rows - 1, max);
        for (let r=validMin; r<=validMax; r++) {
          document.querySelectorAll(`td[data-row="${rowLabels[r]}"]`).forEach(td => td.classList.add('selected'));
        }
      } else if (dragType === 'col' && el.dataset.col) {
        const s = parseInt(startElement.dataset.col);
        const e = parseInt(el.dataset.col);
        const min = Math.min(s,e), max = Math.max(s,e);
        // è¾¹ç•Œæ§åˆ¶ï¼šç¡®ä¿åœ¨æœ‰æ•ˆåˆ—èŒƒå›´å†…
        const validMin = Math.max(1, min);
        const validMax = Math.min(cols, max);
        for (let c=validMin; c<=validMax; c++) {
          document.querySelectorAll(`td[data-col="${c}"]`).forEach(td => td.classList.add('selected'));
        }
      } else if (dragType === 'cell' && el.dataset.row && el.dataset.col) {
        const sr = rowLabels.indexOf(startElement.dataset.row);
        const sc = parseInt(startElement.dataset.col);
        const er = rowLabels.indexOf(el.dataset.row);
        const ec = parseInt(el.dataset.col);
        const rmin = Math.min(sr,er), rmax = Math.max(sr,er);
        const cmin = Math.min(sc,ec), cmax = Math.max(sc,ec);
        
        // è¾¹ç•Œæ§åˆ¶ï¼šç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
        const validRmin = Math.max(0, rmin);
        const validRmax = Math.min(rows - 1, rmax);
        const validCmin = Math.max(1, cmin);
        const validCmax = Math.min(cols, cmax);
        
        // ç›´æ¥æ¡†é€‰ï¼Œæ— å»¶è¿Ÿ
        for (let r=validRmin; r<=validRmax; r++) {
          for (let c=validCmin; c<=validCmax; c++) {
            const td = document.querySelector(`td[data-row="${rowLabels[r]}"][data-col="${c}"]`);
            if (td) td.classList.add('selected');
          }
        }
      }
      updateSidebarInputs();
    };
    
    window.endDrag = function() { 
      isDragging = false; 
      dragType = null; 
    };

    // Apply values
    function applyValues() {
      const sample = document.getElementById('sampleName').value.trim();
      const gene = document.getElementById('targetGene').value.trim();
      const selected = document.querySelectorAll('#grid td.selected');
      selected.forEach(td => {
        if (sample) td.dataset.sampleName = sample;
        if (gene) td.dataset.targetGene = gene;
        updateCellAppearance(td);
        td.classList.remove('selected');
      });
      updateSidebarInputs();
    }
    function removeSelections() { clearSelections(); updateSidebarInputs(); }
    function clearSelectedSampleNames() {
      document.querySelectorAll('#grid td.selected').forEach(td => { td.dataset.sampleName = ''; updateCellAppearance(td); });
      updateSidebarInputs();
    }
    function clearSelectedTargetGenes() {
      document.querySelectorAll('#grid td.selected').forEach(td => { td.dataset.targetGene = ''; updateCellAppearance(td); });
      updateSidebarInputs();
    }
    function clearSelectedValues() {
      const tds = Array.from(document.querySelectorAll('#grid td.selected'));
      if (tds.length === 0) { updateSidebarInputs(); return; }
      tds.forEach(td => {
        td.classList.remove('only-sample','only-gene','both-values');
        td.dataset.sampleName = ''; td.dataset.targetGene=''; td.dataset.ct='';
      });
      // æ‰¹é‡æ›´æ–°å¤–è§‚ï¼Œå‡å°‘é‡ç»˜
      requestAnimationFrame(() => {
        tds.forEach(td => { td.title=''; td.innerHTML=''; updateCellAppearance(td); });
        updateSidebarInputs();
      });
    }
    function resetAll() {
      if (!confirm('Confirm reset all cells? This will clear all sample, gene and CT data.')) return;
      const all = Array.from(document.querySelectorAll('#grid td'));
      all.forEach(td => {
        td.classList.remove('selected','only-sample','only-gene','both-values');
        td.dataset.sampleName = ''; td.dataset.targetGene=''; td.dataset.ct='';
      });
      requestAnimationFrame(() => {
        all.forEach(td => { td.title=''; td.innerHTML=''; updateCellAppearance(td); });
        updateSidebarInputs();
      });
    }



    // Get imported file name (without extension)
    function getImportedFileName() {
      const fileInput = document.getElementById('excelFile');
      if (fileInput.files.length > 0) {
        const fileName = fileInput.files[0].name;
        return fileName.replace(/\.[^/.]+$/, ""); // Remove extension
      }
      return null;
    }

    // XLSX export
    function generateXLSX() {
      // 1) åŸºå› åˆ—ï¼šæŒ‰å‡ºç°é¡ºåºå»é‡
      const geneOrder = [];
      const seenGene = new Set();
      for (let r=0; r<rows; r++) {
        for (let c=1; c<=cols; c++) {
          const td = document.querySelector(`td[data-row="${rowLabels[r]}"][data-col="${c}"]`);
          const g = td.dataset.targetGene || '';
          if (g && !seenGene.has(g)) { seenGene.add(g); geneOrder.push(g); }
        }
      }
      if (geneOrder.length === 0) { alert('No gene names detected, cannot export xlsx'); return; }
      // 2) åˆ†ç»„æ ·æœ¬ï¼šgroup -> gene -> [ct...]
      const groupMap = new Map();
      for (let r=0; r<rows; r++) {
        for (let c=1; c<=cols; c++) {
          const td = document.querySelector(`td[data-row="${rowLabels[r]}"][data-col="${c}"]`);
          const s = td.dataset.sampleName || '';
          const g = td.dataset.targetGene || '';
          const ct = td.dataset.ct || '';
          if (!s || !g) continue;
          if (!groupMap.has(s)) groupMap.set(s, new Map());
          const gmap = groupMap.get(s);
          if (!gmap.has(g)) gmap.set(g, []);
          if (ct) gmap.get(g).push(ct);
          else gmap.get(g).push('NA');
        }
      }
      if (groupMap.size === 0) { alert('No sample-gene pairs detected, cannot export xlsx'); return; }

      // 3) ç»„è£…æ•°æ®è¡¨
      const header = ['num','group name', ...geneOrder];
      const data = [header];
      // ç´¯è®¡è¡Œå·ï¼Œä»1å¼€å§‹ï¼›numä»…åœ¨æ¯ç»„é¦–è¡Œå†™å…¥ï¼Œå…¶ä½™è¡Œç•™ç©º
      let currentIndex = 1;
      for (const [group, gmap] of groupMap.entries()) {
        // æ¯ç»„è¡Œæ•°ä¸ºæ‰€æœ‰åŸºå› æ ·æœ¬çš„æœ€å¤§é•¿åº¦ï¼ˆä»£è¡¨é‡å¤æ¬¡æ•°ï¼‰
        let rowsCount = 0;
        geneOrder.forEach(g => {
          const arr = gmap.get(g) || [];
          rowsCount = Math.max(rowsCount, arr.length);
        });
        if (rowsCount === 0) rowsCount = 1; // è‡³å°‘ä¸€è¡Œ
        for (let i=0; i<rowsCount; i++) {
          const numVal = i === 0 ? currentIndex : '';
          const groupVal = i === 0 ? group : '';
          const row = [numVal, groupVal];
          geneOrder.forEach(g => {
            const arr = gmap.get(g) || [];
            const v = arr[i] !== undefined ? arr[i] : 'NA';
            row.push(v);
          });
          data.push(row);
        }
        currentIndex += rowsCount;
      }

      // 4) ç”Ÿæˆxlsxï¼ˆåˆ—å®½ã€è¡¨å¤´åŠ ç²—ã€æ•°å€¼æ ¼å¼å·¦å¯¹é½ã€å·¥ä½œè¡¨åâ‰¤31ï¼‰
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(data);
      // åˆ—å®½ï¼šnum(8), group(20), genes(14)
      ws['!cols'] = [{ wch: 8 }, { wch: 20 }, ...geneOrder.map(() => ({ wch: 14 }))];

      const ref = ws['!ref'];
      if (ref) {
        const range = XLSX.utils.decode_range(ref);
        // è¡¨å¤´åŠ ç²—ï¼ˆæ ·å¼æ”¯æŒä¾èµ–Excelç‰ˆæœ¬ï¼‰
        for (let c = 0; c <= range.e.c; c++) {
          const addr = XLSX.utils.encode_cell({ r: 0, c });
          if (ws[addr]) ws[addr].s = Object.assign({}, ws[addr].s || {}, { font: { bold: true } });
        }
        // æ‰€æœ‰å•å…ƒæ ¼å·¦å¯¹é½
        for (let r = 0; r <= range.e.r; r++) {
          for (let c = 0; c <= range.e.c; c++) {
            const addr = XLSX.utils.encode_cell({ r, c });
            if (ws[addr]) {
              ws[addr].s = Object.assign({}, ws[addr].s || {}, { alignment: { horizontal: 'left' } });
            }
          }
        }
        // æ•°å€¼æ ¼å¼ä¸º0.00ï¼ˆè·³è¿‡numå’Œgroupä¸¤åˆ—ï¼‰
        for (let r = 1; r <= range.e.r; r++) {
          for (let c = 2; c <= range.e.c; c++) {
            const addr = XLSX.utils.encode_cell({ r, c });
            const cell = ws[addr];
            if (!cell) continue;
            const num = typeof cell.v === 'number' ? cell.v : parseFloat(String(cell.v));
            if (Number.isFinite(num)) {
              cell.v = num;
              cell.t = 'n';
              cell.z = '0.00';
            }
          }
        }
      }

      const inst = document.getElementById('instrument').value;
      const instLabel = inst === 'roche' ? 'Roche' : 'BioRad';
      let wsName = `PlateExport_${instLabel}`;
      wsName = wsName.slice(0, 31); 
      XLSX.utils.book_append_sheet(wb, ws, wsName);

      const summaryHeader = ['group name','gene','N','Missing','Mean','StdDev'];
      const summaryData = [summaryHeader];
      for (const [group, gmap] of groupMap.entries()) {
        geneOrder.forEach(g => {
          const arr = gmap.get(g) || [];
          const nums = arr
            .map(v => (typeof v === 'number' ? v : parseFloat(String(v))))
            .filter(v => Number.isFinite(v));
          const N = nums.length;
          const Missing = arr.length - N;
          let Mean = '';
          let Std = '';
          if (N > 0) {
            const sum = nums.reduce((a,b) => a + b, 0);
            Mean = sum / N;
            if (N > 1) {
              const mean = Mean;
              const variance = nums.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / (N - 1);
              Std = Math.sqrt(variance);
            }
          }
          summaryData.push([group, g, N, Missing, Mean, Std]);
        });
      }
      const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
      wsSummary['!cols'] = [
        { wch: 20 }, // group
        { wch: 14 }, // gene
        { wch: 6 },  // N
        { wch: 8 },  // Missing
        { wch: 10 }, // Mean
        { wch: 10 }  // StdDev
      ];
      const sref = wsSummary['!ref'];
      if (sref) {
        const sr = XLSX.utils.decode_range(sref);
        for (let c = 0; c <= sr.e.c; c++) {
          const addr = XLSX.utils.encode_cell({ r: 0, c });
          if (wsSummary[addr]) wsSummary[addr].s = Object.assign({}, wsSummary[addr].s || {}, { font: { bold: true } });
        }
        // è¡Œ1å¼€å§‹æ˜¯æ•°æ®è¡Œï¼šN/Missingè®¾ä¸ºæ•°å­—ï¼›Mean/StdDevè®¾ä¸ºæ•°å­—å¹¶æ ¼å¼0.00
        for (let r = 1; r <= sr.e.r; r++) {
          // N
          const nAddr = XLSX.utils.encode_cell({ r, c: 2 });
          if (wsSummary[nAddr] && Number.isFinite(parseFloat(String(wsSummary[nAddr].v)))) {
            wsSummary[nAddr].v = parseInt(String(wsSummary[nAddr].v), 10);
            wsSummary[nAddr].t = 'n';
            wsSummary[nAddr].z = '0';
          }
          // Missing
          const mAddr = XLSX.utils.encode_cell({ r, c: 3 });
          if (wsSummary[mAddr] && Number.isFinite(parseFloat(String(wsSummary[mAddr].v)))) {
            wsSummary[mAddr].v = parseInt(String(wsSummary[mAddr].v), 10);
            wsSummary[mAddr].t = 'n';
            wsSummary[mAddr].z = '0';
          }
          // Mean
          const meanAddr = XLSX.utils.encode_cell({ r, c: 4 });
          if (wsSummary[meanAddr] && Number.isFinite(parseFloat(String(wsSummary[meanAddr].v)))) {
            const num = parseFloat(String(wsSummary[meanAddr].v));
            wsSummary[meanAddr].v = num;
            wsSummary[meanAddr].t = 'n';
            wsSummary[meanAddr].z = '0.00';
          }
          // StdDev
          const stdAddr = XLSX.utils.encode_cell({ r, c: 5 });
          if (wsSummary[stdAddr] && Number.isFinite(parseFloat(String(wsSummary[stdAddr].v)))) {
            const num = parseFloat(String(wsSummary[stdAddr].v));
            wsSummary[stdAddr].v = num;
            wsSummary[stdAddr].t = 'n';
            wsSummary[stdAddr].z = '0.00';
          }
        }
      }
      let wsName2 = 'Summary';
      wsName2 = wsName2.slice(0, 31);
      XLSX.utils.book_append_sheet(wb, wsSummary, wsName2);

      let fname = document.getElementById('xlsxFileName').value.trim();
      if (!fname) {
        const importedName = getImportedFileName();
        if (importedName) {
          fname = `${importedName}_trans.xlsx`;
        } else {
          const now = new Date();
          const ds = now.toISOString().slice(0,10);
          const ts = now.toTimeString().slice(0,5).replace(':','-');
          const inst2 = document.getElementById('instrument').value;
          const instLabel2 = inst2 === 'roche' ? 'Roche' : 'BioRad';
          fname = `PlateExport_${instLabel2}_${ds}_${ts}.xlsx`;
        }
      } else if (!fname.endsWith('.xlsx')) {
        fname += '.xlsx';
      }
      XLSX.writeFile(wb, fname);

      // å¯¼å‡ºå½“å‰å­”æ¿è§†å›¾æˆªå›¾ï¼ˆPNGï¼‰
      downloadPlateScreenshot(fname);
    }

    // å¯¼å‡ºå­”æ¿è§†å›¾ä¸ºPNG
    function downloadPlateScreenshot(baseName) {
      const node = document.getElementById('stageWrap');
      const inst = document.getElementById('instrument').value;
      const instLabel = inst === 'roche' ? 'Roche' : 'BioRad';
      const pngName = baseName && baseName.endsWith('.xlsx')
        ? baseName.replace('.xlsx', `_${instLabel}_plate.png`)
        : `PlateExport_${instLabel}_plate.png`;
      html2canvas(node, { backgroundColor: '#ffffff', scale: 2 }).then(canvas => {
        canvas.toBlob(blob => {
          const a = document.createElement('a');
          const url = URL.createObjectURL(blob);
          a.href = url;
          a.download = pngName;
          a.click();
          URL.revokeObjectURL(url);
        });
      });
    }

    // Zoom & Pan
    const stage = document.getElementById('stage');
    const stageWrap = document.getElementById('stageWrap');
    const zoomRange = document.getElementById('zoomRange');
    const viewStatus = document.getElementById('viewStatus');
    let scale = 1;
    let tx = 0, ty = 0;
    let panning = false;
    let panStart = {x:0,y:0};
    let viewStart = {x:0,y:0};

    // å±…ä¸­ç½‘æ ¼æ˜¾ç¤º
    function centerPlate() {
      // ä»¥æœªç¼©æ”¾å‰çš„ç½‘æ ¼å®½é«˜ä¼°ç®—å±…ä¸­ä½ç½®
      const gridNode = document.getElementById('grid');
      const wrapRect = stageWrap.getBoundingClientRect();
      const gridRect = gridNode.getBoundingClientRect();
      // gridRect æ˜¯å½“å‰å˜æ¢åçš„å°ºå¯¸ï¼Œåç®—åŸå§‹å°ºå¯¸
      const gridW = gridRect.width / scale;
      const gridH = gridRect.height / scale;
      tx = Math.round((wrapRect.width - gridW) / 2);
      ty = Math.round((wrapRect.height - gridH) / 2);
      applyTransform();
    }

    function applyTransform() {
      stage.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
      viewStatus.textContent = `scale:${scale.toFixed(2)}, x:${Math.round(tx)}, y:${Math.round(ty)}`;
    }

    stageWrap.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = stage.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const delta = -Math.sign(e.deltaY) * 0.05; // up->zoom in
      const newScale = Math.min(2, Math.max(0.5, scale + delta));

      // ä»¥é¼ æ ‡ä¸ºè¿‘ä¼¼ä¸­å¿ƒç¼©æ”¾ï¼šè°ƒæ•´å¹³ç§»ä¿æŒç„¦ç‚¹ä½ç½®ç›¸å¯¹ç¨³å®š
      const k = newScale / scale;
      tx = mx - k * mx + k * tx;
      ty = my - k * my + k * ty;
      scale = newScale;
      zoomRange.value = scale.toFixed(2);
      applyTransform();
    }, { passive:false });

    // Pan when holding Space or middle button
    stageWrap.addEventListener('mousedown', (e) => {
      if (e.button === 1 || e.buttons === 4 || spacePressed) {
        e.preventDefault();
        panning = true;
        panStart = { x: e.clientX, y: e.clientY };
        viewStart = { x: tx, y: ty };
      }
    });
    window.addEventListener('mousemove', (e) => {
      if (!panning) return;
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;
      tx = viewStart.x + dx;
      ty = viewStart.y + dy;
      applyTransform();
    });
    window.addEventListener('mouseup', () => { panning = false; });
    let spacePressed = false;
    window.addEventListener('keydown', (e) => { if (e.code === 'Space') spacePressed = true; });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') spacePressed = false; });

    zoomRange.addEventListener('input', () => {
      const newScale = parseFloat(zoomRange.value);
      // ç¼©æ”¾ä¸­å¿ƒç”¨è§†å£ä¸­å¿ƒ
      const rect = stageWrap.getBoundingClientRect();
      const mx = rect.width/2;
      const my = rect.height/2;
      const k = newScale / scale;
      tx = mx - k * mx + k * tx;
      ty = my - k * my + k * ty;
      scale = newScale;
      applyTransform();
    });
    document.getElementById('resetView').addEventListener('click', () => {
      scale = 1;
      zoomRange.value = '1';
      centerPlate();
    });

    // Wire buttons
    document.getElementById('applyBtn').addEventListener('click', applyValues);
    document.getElementById('removeSelBtn').addEventListener('click', removeSelections);
    document.getElementById('clearSampleBtn').addEventListener('click', clearSelectedSampleNames);
    document.getElementById('clearGeneBtn').addEventListener('click', clearSelectedTargetGenes);
    document.getElementById('clearValuesBtn').addEventListener('click', clearSelectedValues);
    document.getElementById('resetAllBtn').addEventListener('click', resetAll);

    document.getElementById('exportXLSXBtn').addEventListener('click', generateXLSX);

    // Enter é”®è§¦å‘ Applyï¼ˆä»…åœ¨æ— ä¿®é¥°é”®ä¸”å­˜åœ¨é€‰ä¸­å•å…ƒæ ¼æ—¶ï¼‰
    function handleEnterApply(e) {
      if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
        const selected = document.querySelectorAll('#grid td.selected');
        if (selected.length > 0) {
          e.preventDefault();
          applyValues();
        }
      }
    }
    // åœ¨ä¸¤ä¸ªè¾“å…¥æ¡†é‡ŒæŒ‰ Enter è§¦å‘
    document.getElementById('sampleName').addEventListener('keydown', handleEnterApply);
    document.getElementById('targetGene').addEventListener('keydown', handleEnterApply);
    // åœ¨ä¾§æ å…¶å®ƒåŒºåŸŸæŒ‰ Enter ä¹Ÿå¯è§¦å‘ï¼ˆé¿å…åœ¨æ–‡ä»¶è¾“å…¥æˆ–æŒ‰é’®ä¸Šè§¦å‘ï¼‰
    document.querySelector('.sidebar').addEventListener('keydown', (e) => {
      const tag = e.target.tagName.toLowerCase();
      if (tag === 'input' || tag === 'select' || tag === 'textarea') return; // å·²ç”±ä¸“ç”¨ç›‘å¬å¤„ç†
      handleEnterApply(e);
    });

    // Excel å¯¼å…¥
    // Web Workerï¼šåœ¨åå°è§£æExcelï¼Œä¸»çº¿ç¨‹ä»…è´Ÿè´£æ¸²æŸ“ä¸UI
    let excelWorker = null;
    function initExcelWorker() {
      const workerCode = `
self.importScripts('https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js');
function readRowsWithHeader(ws, required) {
  const a2 = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });
  let headerIdx = -1;
  let header = null;
  for (let i = 0; i < a2.length; i++) {
    const row = a2[i].map(v => String(v).trim());
    const lower = row.map(v => v.toLowerCase());
    const ok = required.every(key => lower.includes(key.toLowerCase()));
    if (ok) { headerIdx = i; header = row; break; }
  }
  if (headerIdx === -1) return [];
  const rows = [];
  for (let i = headerIdx + 1; i < a2.length; i++) {
    const r = a2[i];
    if (!r || r.length === 0) continue;
    const obj = {};
    header.forEach((h, idx) => { obj[String(h).trim()] = r[idx]; });
    rows.push(obj);
  }
  return rows;
}
function getVal(obj, names) {
  for (const n of names) {
    const k = Object.keys(obj).find(key => key.toLowerCase() === n.toLowerCase());
    if (k) return obj[k];
  }
  return '';
}
self.onmessage = function(e) {
  const { buffer } = e.data;
  let detected = null;
  let imported = 0;
  const wb = XLSX.read(buffer, { type: 'array' });
  const results = [];
  for (const sheetName of wb.SheetNames) {
    const ws = wb.Sheets[sheetName];
    // Try Bio-Rad
    let rows = readRowsWithHeader(ws, ['Well','Target','Sample','Cq']);
    if (rows.length > 0) {
      detected = 'biorad';
      for (const row of rows) {
        const well = getVal(row, ['Well']);
        const target = getVal(row, ['Target']);
        const sample = getVal(row, ['Sample']);
        const cq = getVal(row, ['Cq']);
        results.push({ pos: well, sample, gene: target, ct: cq });
        imported++;
      }
      continue;
    }
    // Try Roche
    rows = readRowsWithHeader(ws, ['Pos','Name','Cp']);
    if (rows.length > 0) {
      detected = detected || 'roche';
      for (const row of rows) {
        const pos = getVal(row, ['Pos']);
        const name = getVal(row, ['Name']);
        const cp = getVal(row, ['Cp']);
        results.push({ pos, sample: name, gene: pos, ct: cp });
        imported++;
      }
      continue;
    }
  }
  self.postMessage({ detected, imported, results });
};
`;
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      excelWorker = new Worker(url);
    }
    function normalizePos(pos) {
      if (!pos) return null;
      const m = String(pos).trim().toUpperCase().match(/^([A-P])0*([1-9]|1[0-9]|2[0-4])$/);
      if (!m) return null;
      return m[1] + String(parseInt(m[2], 10));
    }
    function setCellByPos(pos, sample, gene, ct) {
      const norm = normalizePos(pos);
      if (!norm) return false;
      const row = norm[0];
      const col = parseInt(norm.slice(1), 10);
      const td = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
      if (!td) return false;
      if (sample !== undefined) td.dataset.sampleName = sample || '';
      if (gene !== undefined) td.dataset.targetGene = gene || '';
      if (ct !== undefined) td.dataset.ct = ct !== '' && ct !== null && ct !== undefined ? String(ct) : '';
      updateCellAppearance(td);
      return true;
    }
    function readRowsWithHeader(ws, required) {
      // ä»¥ header:1 è¯»å–äºŒç»´æ•°ç»„ï¼ŒæŸ¥æ‰¾åŒ…å«æ‰€éœ€åˆ—çš„è¡¨å¤´è¡Œ
      const a2 = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });
      let headerIdx = -1;
      let header = null;
      for (let i = 0; i < a2.length; i++) {
        const row = a2[i].map(v => String(v).trim());
        const lower = row.map(v => v.toLowerCase());
        const ok = required.every(key => lower.includes(key.toLowerCase()));
        if (ok) { headerIdx = i; header = row; break; }
      }
      if (headerIdx === -1) return [];
      const rows = [];
      for (let i = headerIdx + 1; i < a2.length; i++) {
        const r = a2[i];
        if (!r || r.length === 0) continue;
        const obj = {};
        header.forEach((h, idx) => { obj[String(h).trim()] = r[idx]; });
        rows.push(obj);
      }
      return rows;
    }
    function getVal(obj, names) {
      for (const n of names) {
        const k = Object.keys(obj).find(key => key.toLowerCase() === n.toLowerCase());
        if (k) return obj[k];
      }
      return '';
    }
    async function importExcelFile(file) {
      const buf = await file.arrayBuffer();
      if (!excelWorker) initExcelWorker();
      return new Promise((resolve) => {
        excelWorker.onmessage = (e) => {
          const { detected, imported, results } = e.data || {};
          let countSet = 0;
          if (Array.isArray(results)) {
            results.forEach(({ pos, sample, gene, ct }) => {
              if (setCellByPos(pos, sample, gene, ct)) countSet++;
            });
          }
          if (!detected || imported === 0 || countSet === 0) {
            alert('No valid Bio-Rad or Roche data headers detected, please check Excel file format.');
            resolve({ detected: null, imported: 0 });
            return;
          }
          const instSel = document.getElementById('instrument');
          if (detected === 'biorad') instSel.value = 'biorad';
          else if (detected === 'roche') instSel.value = 'roche';
          alert(`Import completed: ${detected === 'biorad' ? 'Bio-Rad' : 'Roche'} data, ${countSet} wells updated.`);
          resolve({ detected, imported: countSet });
        };
        // å°†ArrayBufferè½¬ç§»åˆ°Workerï¼Œé¿å…å¤åˆ¶
        excelWorker.postMessage({ buffer: buf }, [buf]);
      });
    }

    // æ–‡ä»¶é€‰æ‹©åè‡ªåŠ¨å¯¼å…¥æ•°æ®
    document.getElementById('excelFile').addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      const fileInput = document.getElementById('excelFile');
      fileInput.disabled = true;
      fileInput.style.opacity = '0.7';
      
      // æ¸…ç©ºå½“å‰æ•°æ®
      document.querySelectorAll('#grid td').forEach(td => {
        td.classList.remove('selected','only-sample','only-gene','both-values');
        td.dataset.sampleName = ''; td.dataset.targetGene = ''; td.dataset.ct = '';
        td.title=''; td.innerHTML='';
      });
      
      try {
        await importExcelFile(file);
        updateSidebarInputs();
        
        // å¯¼å…¥æˆåŠŸåæ¸…ç©ºæ–‡ä»¶é€‰æ‹©ï¼Œå…è®¸é‡æ–°é€‰æ‹©
        e.target.value = '';
        
        // æ¢å¤æ–‡ä»¶è¾“å…¥çŠ¶æ€
        fileInput.disabled = false;
        fileInput.style.opacity = '1';
        
      } catch (error) {
        console.error('å¯¼å…¥å¤±è´¥:', error);
        alert('File import failed, please check if the file format is correct.');
        
        // æ¢å¤æ–‡ä»¶è¾“å…¥çŠ¶æ€
        fileInput.disabled = false;
        fileInput.style.opacity = '1';
      }
    });

    // Init
    createGrid();
    // Initialize cell dataset
    document.querySelectorAll('#grid td').forEach(td => { td.dataset.sampleName=''; td.dataset.targetGene=''; td.dataset.ct=''; });
    // åˆå§‹å±…ä¸­
    centerPlate();
    // çª—å£å°ºå¯¸å˜åŒ–æ—¶ä¿æŒå±…ä¸­
    window.addEventListener('resize', () => { centerPlate(); });
  </script>
</body>
</html>

<!--  Designed by Guanghan Fan & Tecent Codebuddy