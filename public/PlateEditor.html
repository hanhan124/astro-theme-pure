<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PlateEditor</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üß¨</text></svg>">
  <style>
    :root {
      --primary: #4285F4;
      --primary-dark: #3367D6;
      --secondary: #9AA0A6;
      --success: #34A853;
      --warning: #FBBC05;
      --danger: #EA4335;
      --surface: #FFFFFF;
      --surface-alt: #F8F9FA;
      --border: #DADCE0;
      --text-primary: #3C4043;
      --text-secondary: #5F6368;
      --text-muted: #80868B;
      --shadow-sm: 0 1px 2px rgba(60,64,67,0.3);
      --shadow-md: 0 2px 6px rgba(60,64,67,0.15);
      --shadow-lg: 0 4px 12px rgba(60,64,67,0.15);
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --blur-bg: rgba(255,255,255,0.95);
    }
    
    body { 
      font-family: 'Roboto', 'Noto Sans SC', 'Microsoft YaHei', sans-serif; 
      background: linear-gradient(135deg, #F1F3F4 0%, #E8EAED 100%); 
      margin: 0; 
      color: var(--text-primary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
    }
    
    .container { 
      display: flex; 
      gap: 0; 
      height: 100vh; 
      max-height: 100vh;
      background: var(--surface);
      border-radius: var(--radius-lg);
      margin: 8px;
      box-shadow: var(--shadow-lg);
      overflow: hidden;
    }
    
    .left { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      background: var(--surface);
      border-radius: var(--radius-lg) 0 0 var(--radius-lg);
      border-right: 1px solid var(--border);
    }
    
    .stage-wrap { 
      flex: 1; 
      position: relative; 
      overflow: hidden; 
      background: var(--surface); 
      border-right: 1px solid var(--border);
    }
    
    .stage { 
      position: absolute; 
      left: 0; 
      top: 0; 
      transform-origin: 0 0; 
    }
    
    .grid-container { 
      padding: 20px; 
      background: var(--surface);
    }
    
    #grid { 
      border-collapse: separate; 
      border-spacing: 1px;
      background: var(--surface); 
      box-shadow: var(--shadow-md);
      border-radius: var(--radius-md);
      overflow: hidden;
      border: 1px solid var(--border);
    }
    
    #grid th, #grid td { 
      border: 1px solid var(--border);
      width: 38px; 
      height: 38px; 
      text-align: center; 
      vertical-align: middle; 
      font-size: 11px; 
      line-height: 1.2; 
      transition: all 0.15s ease;
      background: var(--surface);
    }
    
    #grid th { 
      background: linear-gradient(135deg, #F8F9FA 0%, #E8EAED 100%); 
      font-weight: 600; 
      cursor: pointer; 
      user-select: none; 
      color: var(--text-primary); 
      position: sticky; 
      z-index: 1; 
      border-bottom: 2px solid var(--border);
      font-size: 10px;
      letter-spacing: 0.3px;
    }
    
    #grid th:hover {
      background: linear-gradient(135deg, #E8F0FE 0%, #D2E3FC 100%);
      transform: translateY(-1px);
      box-shadow: 0 1px 4px rgba(26,115,232,0.2);
    }
    
    #grid td { 
      cursor: pointer; 
      background: var(--surface); 
      position: relative;
    }
    
    #grid td:hover {
      background: #F8F9FA;
      transform: scale(1.02);
      z-index: 2;
      box-shadow: 0 2px 8px rgba(26,115,232,0.15);
      border-color: var(--primary);
    }
    
    #grid td.selected { 
      outline: 2px solid var(--primary); 
      outline-offset: -1px; 
      background: rgba(26,115,232,0.08);
      box-shadow: 0 0 0 1px var(--primary) inset;
      position: relative;
      z-index: 10;
      border-color: var(--primary);
    }
    
    #grid td.selected::before {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      border: 2px solid var(--primary);
      border-radius: 2px;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    
    #grid td.only-sample { 
      background: linear-gradient(135deg, #FFF9C4 0%, #FFF59D 100%); 
      color: #2D3748; 
      font-weight: 500;
      border: 1px solid #FFEB3B;
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.8);
    }
    
    #grid td.only-gene { 
      background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%); 
      color: #2D3748; 
      font-weight: 500;
      border: 1px solid #90CAF9;
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.8);
    }
    
    #grid td.both-values { 
      background: linear-gradient(135deg, #E8F5E8 0%, #C8E6C9 100%); 
      color: #2D3748; 
      font-weight: 500;
      border: 1px solid #A5D6A7;
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.8);
    }
    
    .value-text { 
      display: inline-block; 
      padding: 2px 4px; 
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 4px; 
      margin: 1px 0; 
      font-weight: 500;
      box-shadow: 0 1px 1px rgba(0,0,0,0.05);
      font-size: 10px;
    }
    
    .target-gene { 
      font-style: italic; 
      font-weight: 500;
    }
    
    .toolbar { 
      padding: 12px 20px; 
      border-top: 1px solid var(--border); 
      background: var(--surface);
      display: flex; 
      align-items: center; 
      gap: 12px; 
      min-height: 52px;
    }
    
    .right { 
      width: 300px; 
      background: var(--surface);
      border-left: 1px solid var(--border); 
      display: flex; 
      flex-direction: column; 
      border-radius: 0 var(--radius-lg) var(--radius-lg) 0;
      box-shadow: -1px 0 8px rgba(60,64,67,0.1);
      /* ÂÖÅËÆ∏‰æßÊ†èÂá∫Áé∞ÊªöÂä®ÔºåËÄå‰∏çÊòØË£ÅÂàáÂÜÖÂÆπ */
      overflow: auto;
      flex-shrink: 0;
    }
    
    .sidebar { 
      padding: 16px; 
      overflow-y: auto;  /* Ê∑ªÂä†ÂûÇÁõ¥ÊªöÂä® */
      overflow-x: hidden; /* Èò≤Ê≠¢Ê∞¥Âπ≥ÊªöÂä® */
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: calc(100vh - 32px);
      box-sizing: border-box;
    }
    
    .sidebar h2 { 
      margin: 0; 
      font-size: 14px; 
      font-weight: 600; 
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 0 4px 0;
      border-bottom: 1px solid var(--border);
      letter-spacing: 0.2px;
    }
    
    .sidebar h2::before {
      content: "üß¨";
      font-size: 16px;
    }
    
    .form-row { 
      margin-bottom: 0; 
      padding: 6px 0;
      border-bottom: 1px solid var(--surface-alt);
    }
    
    .form-row label { 
      display: block; 
      font-size: 11px; 
      color: var(--text-secondary);
      margin-bottom: 6px; 
      font-weight: 500;
      letter-spacing: 0.2px;
    }
    
    .form-row input, .form-row select { 
      width: 100%; 
      padding: 8px 12px; 
      border: 1px solid var(--border);
      border-radius: var(--radius-sm); 
      font-size: 13px; 
      background: var(--surface); 
      transition: all 0.15s ease;
      font-family: 'Roboto', 'Noto Sans SC', sans-serif;
      box-sizing: border-box;
    }
    
    .form-row input:focus, .form-row select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(26,115,232,0.1);
    }
    
    .form-row input::placeholder {
      color: var(--text-muted);
      opacity: 0.7;
    }
    
    .btn { 
      width: 100%; 
      padding: 10px 12px; 
      font-size: 13px; 
      font-weight: 600; 
      color: #ffffff;
      border: none; 
      border-radius: var(--radius-sm); 
      cursor: pointer; 
      margin-bottom: 6px; 
      transition: all 0.15s ease;
      position: relative;
      /* ÈÅøÂÖçÊåâÈíÆÂÜÖÈÉ®ÂÜÖÂÆπË¢´Ë£ÅÂàá */
      overflow: visible;
      letter-spacing: 0.2px;
    }
    
    .btn-large { 
      padding: 14px 16px; 
      font-size: 15px; 
      font-weight: 700;
      margin-bottom: 12px;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.3s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn-primary { 
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); 
      box-shadow: 0 2px 8px rgba(142,197,252,0.2);
    }
    
    .btn-gray { 
      background: linear-gradient(135deg, var(--secondary) 0%, #B0B0B5 100%); 
    }
    
    .btn-orange { 
      background: linear-gradient(135deg, var(--warning) 0%, #FFC085 100%); 
    }
    
    .btn-red { 
      background: linear-gradient(135deg, var(--danger) 0%, #FF8C94 100%); 
      box-shadow: 0 2px 8px rgba(255,179,186,0.2);
    }
    
    .btn-green { 
      background: linear-gradient(135deg, var(--success) 0%, #8CDBB5 100%); 
      box-shadow: 0 2px 8px rgba(168,230,207,0.2);
    }
    
    .btn:hover { 
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .small { 
      font-size: 11px; 
      color: var(--text-muted);
    }
    
    #grid td, #grid th {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    .compact-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
      margin-bottom: 6px;
    }
    
    .compact-grid .btn {
      margin-bottom: 0;
      padding: 6px;
      font-size: 11px;
    }
    
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: var(--text-muted);
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 0 1px var(--success);
      animation: pulse 2s ease-in-out infinite;
    }
    
    .sidebar::-webkit-scrollbar {
      width: 8px;
    }
    
    .sidebar::-webkit-scrollbar-track {
      background: var(--surface-alt);
      border-radius: 4px;
    }
    
    .sidebar::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    
    .sidebar::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }
    
    input[type="file"] {
      padding: 12px 16px;
      border: 2px dashed var(--border);
      border-radius: 12px;
      background: var(--surface-alt);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    input[type="file"]:hover {
      border-color: var(--primary);
      background: rgba(0, 122, 255, 0.05);
    }
    
    input[type="file"]::file-selector-button {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      background: var(--primary);
      color: white;
      font-weight: 600;
      cursor: pointer;
      margin-right: 12px;
      transition: all 0.2s ease;
    }
    
    input[type="file"]::file-selector-button:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }
  </style>
  <!-- SheetJS for xlsx export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- html2canvas for screenshot export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="left">
      <div class="stage-wrap" id="stageWrap" aria-label="Plate viewport">
        <div class="stage" id="stage" style="transform: translate(0px, 0px) scale(1);">
          <div class="grid-container">
            <table id="grid"></table>
          </div>
        </div>
      </div>
      <div class="toolbar">
        <div class="status-indicator">
          <div class="status-dot"></div>
          <span>Ready</span>
        </div>
        <input id="zoomRange" type="range" min="0.5" max="2" step="0.01" value="1" style="width:120px;" title="Zoom scale">
        <button id="resetView" class="btn btn-gray" style="width:auto; padding:8px 12px; font-size:12px;">Reset</button>
        <span class="small" id="viewStatus" style="margin-left:auto;">Scale:1.00</span>
      </div>
    </div>

    <div class="right">
      <div class="sidebar">
        <h1>üìë PlateEditor</h1>

        <div class="form-row">
          <label for="instrument">Instrument Type</label>
          <select id="instrument">
            <option value="biorad">Bio-Rad CFX384</option>
            <option value="roche">Roche LightCycler¬Æ 480</option>
          </select>
        </div>

        <h2 style="margin-top:20px; border-bottom: 1px solid var(--border); padding-bottom: 6px;">Data Import</h2>
        <div class="form-row">
          <label for="excelFile">Select Excel File (Auto Import)</label>
          <input type="file" id="excelFile" accept=".xlsx,.xls">
        </div>
        <div style="font-size: 11px; color: var(--text-muted); margin-top: -8px; margin-bottom: 12px;">
          Data will be automatically imported after file selection
        </div>


        <div class="form-row">
          <label for="targetGene">Target Gene</label>
          <input type="text" id="targetGene" placeholder="Enter gene name">
        </div>
          
        <div class="form-row">
          <label for="sampleName">Sample Name</label>
          <input type="text" id="sampleName" placeholder="Enter sample name">
        </div>

        <button class="btn btn-primary btn-large" id="applyBtn">Apply</button>

        <div class="compact-grid">
          <button class="btn btn-gray" id="removeSelBtn">Clear Selection</button>
          <button class="btn btn-gray" id="clearSampleBtn">Clear Sample</button>
          <button class="btn btn-gray" id="clearGeneBtn">Clear Gene</button>
          <button class="btn btn-gray" id="clearValuesBtn">Clear Values</button>
        </div>

        <button class="btn btn-red" id="resetAllBtn">Reset All Data</button>


        <h2 style="margin-top:20px; border-bottom: 1px solid var(--border); padding-bottom: 6px;">Data Export</h2>
        <div class="form-row">
          <label for="xlsxFileName">File Name</label>
          <input type="text" id="xlsxFileName" placeholder="Default timestamp">
        </div>
        <button class="btn btn-green btn-large" id="exportXLSXBtn">Export</button>
        <div style="text-align: center; margin-top: 8px; font-size: 10px; color: #80868B; font-style: normal;">
          Designed by FGH & Tecent Codebuddy
        </div>
      </div>
    </div>
  </div>

  <script>
    const rows = 16;
    const cols = 24;
    const rowLabels = Array.from({length: rows}, (_, i) => String.fromCharCode(65 + i)); // A..P
    const grid = document.getElementById('grid');

    // Selection state
    let isDragging = false;
    let startElement = null;
    let dragType = null; // 'cell','row','col'
    // Colors
    const colorPalette = [
      '#FF3B30','#FF9500','#FFCC00','#4CD964','#5AC8FA',
      '#007AFF','#5856D6','#FF2D55','#FF3B30','#FF9500',
      '#FFCC00','#4CD964','#5AC8FA','#007AFF','#5856D6',
      '#FF2D55','#8E8E93','#C7C7CC','#D1D1D6','#E5E5EA'
    ];
    const MAX_COLOR_MAP = 200;
    const sampleNameColors = new Map();
    const targetGeneColors = new Map();
    function getValueColor(value, type) {
      const map = type === 'sample' ? sampleNameColors : targetGeneColors;
      if (!value) return '#fff';
      if (!map.has(value)) {
        if (map.size >= MAX_COLOR_MAP) {
          const firstKey = map.keys().next().value;
          map.delete(firstKey);
        }
        const lightColors = [
          '#F8FBFF', '#F9F7FF', '#F7FFF7', '#FFFCF5', '#FFF5F8',
          '#F5FFFE', '#FDFFF7', '#FFFEF5', '#F7F8FF', '#F7FFF9',
          '#F5FEFF', '#F9F7FF', '#F7FFF7', '#FFFCF5', '#FFF5F8'
        ];
        const colorIndex = map.size % lightColors.length;
        map.set(value, lightColors[colorIndex]);
      }
      return map.get(value);
    }

    // Build grid
    function createGrid() {
      grid.innerHTML = '';
      let header = '<tr><th></th>';
      for (let c=1; c<=cols; c++) {
        header += `<th data-col="${c}" onmousedown="startDrag(this,'col')" onmouseover="dragSelect(this)" onmouseup="endDrag()">${c}</th>`;
      }
      header += '</tr>';
      grid.innerHTML += header;

      for (let r=0; r<rows; r++) {
        let rowHTML = `<tr><th data-row="${rowLabels[r]}" onmousedown="startDrag(this,'row')" onmouseover="dragSelect(this)" onmouseup="endDrag()">${rowLabels[r]}</th>`;
        for (let c=1; c<=cols; c++) {
          rowHTML += `<td data-row="${rowLabels[r]}" data-col="${c}" onmousedown="startDrag(this,'cell')" onmouseover="dragSelect(this)" onmouseup="endDrag()"></td>`;
        }
        rowHTML += '</tr>';
        grid.innerHTML += rowHTML;
      }
    }

    // Update cell display
    function updateCellAppearance(cell) {
      const sample = cell.dataset.sampleName || '';
      const gene = cell.dataset.targetGene || '';
      const ct = cell.dataset.ct || '';
      cell.classList.remove('only-sample','only-gene','both-values');

      let html = '';
      if (sample && gene) {
        cell.classList.add('both-values');
        html = `<span class="value-text" style="background:${getValueColor(sample,'sample')}">${sample}</span><br><span class="value-text target-gene" style="background:${getValueColor(gene,'gene')}">${gene}</span>`;
      } else if (sample) {
        cell.classList.add('only-sample');
        html = `<span class="value-text" style="background:${getValueColor(sample,'sample')}">${sample}</span>`;
      } else if (gene) {
        cell.classList.add('only-gene');
        html = `<span class="value-text target-gene" style="background:${getValueColor(gene,'gene')}">${gene}</span>`;
      }
      cell.innerHTML = html;
      const inst = document.getElementById('instrument').value;
      const ctLabel = inst === 'roche' ? 'Cp' : 'Cq';
      cell.title = `Pos ${cell.dataset.row}${cell.dataset.col} | Sample: ${sample || 'None'} | Gene: ${gene || 'None'} | ${ctLabel}: ${ct || 'NA'}`;
    }

    // Sidebar inputs sync
    function updateSidebarInputs() {
      const selected = document.querySelectorAll('#grid td.selected');
      const sampleInput = document.getElementById('sampleName');
      const geneInput = document.getElementById('targetGene');

      if (selected.length > 0) {
        const samples = Array.from(selected).map(td => td.dataset.sampleName || '');
        const genes = Array.from(selected).map(td => td.dataset.targetGene || '');
        const us = [...new Set(samples)];
        const ug = [...new Set(genes)];
        sampleInput.value = us.length === 1 ? us[0] : '';
        geneInput.value = ug.length === 1 ? ug[0] : '';
      } else {
        sampleInput.value = '';
        geneInput.value = '';
      }
    }

    // Selection helpers - Êó†Âª∂ËøüÊ°ÜÈÄâ
    function clearSelections() {
      document.querySelectorAll('#grid td.selected').forEach(td => td.classList.remove('selected'));
    }
    
    window.startDrag = function(el, type) {
      isDragging = true;
      startElement = el;
      dragType = type;
      clearSelections();
      if (type === 'row') {
        const label = el.dataset.row;
        document.querySelectorAll(`td[data-row="${label}"]`).forEach(td => td.classList.add('selected'));
      } else if (type === 'col') {
        const col = parseInt(el.dataset.col);
        document.querySelectorAll(`td[data-col="${col}"]`).forEach(td => td.classList.add('selected'));
      } else if (type === 'cell') {
        el.classList.add('selected');
      }
      updateSidebarInputs();
    };
    
    window.dragSelect = function(el) {
      if (!isDragging) return;
      
      clearSelections();
      
      // Áõ¥Êé•ÊâßË°åÔºåÊó†Âª∂Ëøü‰ºòÂåñ
      if (dragType === 'row' && el.dataset.row) {
        const s = rowLabels.indexOf(startElement.dataset.row);
        const e = rowLabels.indexOf(el.dataset.row);
        const min = Math.min(s,e), max = Math.max(s,e);
        // ËæπÁïåÊéßÂà∂ÔºöÁ°Æ‰øùÂú®ÊúâÊïàË°åËåÉÂõ¥ÂÜÖ
        const validMin = Math.max(0, min);
        const validMax = Math.min(rows - 1, max);
        for (let r=validMin; r<=validMax; r++) {
          document.querySelectorAll(`td[data-row="${rowLabels[r]}"]`).forEach(td => td.classList.add('selected'));
        }
      } else if (dragType === 'col' && el.dataset.col) {
        const s = parseInt(startElement.dataset.col);
        const e = parseInt(el.dataset.col);
        const min = Math.min(s,e), max = Math.max(s,e);
        // ËæπÁïåÊéßÂà∂ÔºöÁ°Æ‰øùÂú®ÊúâÊïàÂàóËåÉÂõ¥ÂÜÖ
        const validMin = Math.max(1, min);
        const validMax = Math.min(cols, max);
        for (let c=validMin; c<=validMax; c++) {
          document.querySelectorAll(`td[data-col="${c}"]`).forEach(td => td.classList.add('selected'));
        }
      } else if (dragType === 'cell' && el.dataset.row && el.dataset.col) {
        const sr = rowLabels.indexOf(startElement.dataset.row);
        const sc = parseInt(startElement.dataset.col);
        const er = rowLabels.indexOf(el.dataset.row);
        const ec = parseInt(el.dataset.col);
        const rmin = Math.min(sr,er), rmax = Math.max(sr,er);
        const cmin = Math.min(sc,ec), cmax = Math.max(sc,ec);
        
        // ËæπÁïåÊéßÂà∂ÔºöÁ°Æ‰øùÂú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
        const validRmin = Math.max(0, rmin);
        const validRmax = Math.min(rows - 1, rmax);
        const validCmin = Math.max(1, cmin);
        const validCmax = Math.min(cols, cmax);
        
        // Áõ¥Êé•Ê°ÜÈÄâÔºåÊó†Âª∂Ëøü
        for (let r=validRmin; r<=validRmax; r++) {
          for (let c=validCmin; c<=validCmax; c++) {
            const td = document.querySelector(`td[data-row="${rowLabels[r]}"][data-col="${c}"]`);
            if (td) td.classList.add('selected');
          }
        }
      }
      updateSidebarInputs();
    };
    
    window.endDrag = function() { 
      isDragging = false; 
      dragType = null; 
    };

    // Apply values
    function applyValues() {
      const sample = document.getElementById('sampleName').value.trim();
      const gene = document.getElementById('targetGene').value.trim();
      const selected = document.querySelectorAll('#grid td.selected');
      selected.forEach(td => {
        if (sample) td.dataset.sampleName = sample;
        if (gene) td.dataset.targetGene = gene;
        updateCellAppearance(td);
        td.classList.remove('selected');
      });
      updateSidebarInputs();
    }
    function removeSelections() { clearSelections(); updateSidebarInputs(); }
    function clearSelectedSampleNames() {
      document.querySelectorAll('#grid td.selected').forEach(td => { td.dataset.sampleName = ''; updateCellAppearance(td); });
      updateSidebarInputs();
    }
    function clearSelectedTargetGenes() {
      document.querySelectorAll('#grid td.selected').forEach(td => { td.dataset.targetGene = ''; updateCellAppearance(td); });
      updateSidebarInputs();
    }
    function clearSelectedValues() {
      const tds = Array.from(document.querySelectorAll('#grid td.selected'));
      if (tds.length === 0) { updateSidebarInputs(); return; }
      tds.forEach(td => {
        td.classList.remove('only-sample','only-gene','both-values');
        td.dataset.sampleName = ''; td.dataset.targetGene=''; td.dataset.ct='';
      });
      // ÊâπÈáèÊõ¥Êñ∞Â§ñËßÇÔºåÂáèÂ∞ëÈáçÁªò
      requestAnimationFrame(() => {
        tds.forEach(td => { td.title=''; td.innerHTML=''; updateCellAppearance(td); });
        updateSidebarInputs();
      });
    }
    function resetAll() {
      if (!confirm('Confirm reset all cells? This will clear all sample, gene and CT data.')) return;
      const all = Array.from(document.querySelectorAll('#grid td'));
      all.forEach(td => {
        td.classList.remove('selected','only-sample','only-gene','both-values');
        td.dataset.sampleName = ''; td.dataset.targetGene=''; td.dataset.ct='';
      });
      requestAnimationFrame(() => {
        all.forEach(td => { td.title=''; td.innerHTML=''; updateCellAppearance(td); });
        updateSidebarInputs();
      });
    }



    // Get imported file name (without extension)
    function getImportedFileName() {
      const fileInput = document.getElementById('excelFile');
      if (fileInput.files.length > 0) {
        const fileName = fileInput.files[0].name;
        return fileName.replace(/\.[^/.]+$/, ""); // Remove extension
      }
      return null;
    }

    // XLSX export
    function generateXLSX() {
      // 1) Âü∫Âõ†ÂàóÔºöÊåâÂá∫Áé∞È°∫Â∫èÂéªÈáç
      const geneOrder = [];
      const seenGene = new Set();
      for (let r=0; r<rows; r++) {
        for (let c=1; c<=cols; c++) {
          const td = document.querySelector(`td[data-row="${rowLabels[r]}"][data-col="${c}"]`);
          const g = td.dataset.targetGene || '';
          if (g && !seenGene.has(g)) { seenGene.add(g); geneOrder.push(g); }
        }
      }
      if (geneOrder.length === 0) { alert('No gene names detected, cannot export xlsx'); return; }
      // 2) ÂàÜÁªÑÊ†∑Êú¨Ôºögroup -> gene -> [ct...]
      const groupMap = new Map();
      for (let r=0; r<rows; r++) {
        for (let c=1; c<=cols; c++) {
          const td = document.querySelector(`td[data-row="${rowLabels[r]}"][data-col="${c}"]`);
          const s = td.dataset.sampleName || '';
          const g = td.dataset.targetGene || '';
          const ct = td.dataset.ct || '';
          if (!s || !g) continue;
          if (!groupMap.has(s)) groupMap.set(s, new Map());
          const gmap = groupMap.get(s);
          if (!gmap.has(g)) gmap.set(g, []);
          if (ct) gmap.get(g).push(ct);
          else gmap.get(g).push('NA');
        }
      }
      if (groupMap.size === 0) { alert('No sample-gene pairs detected, cannot export xlsx'); return; }

      // 3) ÁªÑË£ÖÊï∞ÊçÆË°®
      const header = ['num','group name', ...geneOrder];
      const data = [header];
      // Á¥ØËÆ°Ë°åÂè∑Ôºå‰ªé1ÂºÄÂßãÔºõnum‰ªÖÂú®ÊØèÁªÑÈ¶ñË°åÂÜôÂÖ•ÔºåÂÖ∂‰ΩôË°åÁïôÁ©∫
      let currentIndex = 1;
      for (const [group, gmap] of groupMap.entries()) {
        // ÊØèÁªÑË°åÊï∞‰∏∫ÊâÄÊúâÂü∫Âõ†Ê†∑Êú¨ÁöÑÊúÄÂ§ßÈïøÂ∫¶Ôºà‰ª£Ë°®ÈáçÂ§çÊ¨°Êï∞Ôºâ
        let rowsCount = 0;
        geneOrder.forEach(g => {
          const arr = gmap.get(g) || [];
          rowsCount = Math.max(rowsCount, arr.length);
        });
        if (rowsCount === 0) rowsCount = 1; // Ëá≥Â∞ë‰∏ÄË°å
        for (let i=0; i<rowsCount; i++) {
          const numVal = i === 0 ? currentIndex : '';
          const groupVal = i === 0 ? group : '';
          const row = [numVal, groupVal];
          geneOrder.forEach(g => {
            const arr = gmap.get(g) || [];
            const v = arr[i] !== undefined ? arr[i] : 'NA';
            row.push(v);
          });
          data.push(row);
        }
        currentIndex += rowsCount;
      }

      // 4) ÁîüÊàêxlsxÔºàÂàóÂÆΩ„ÄÅË°®Â§¥Âä†Á≤ó„ÄÅÊï∞ÂÄºÊ†ºÂºèÂ∑¶ÂØπÈΩê„ÄÅÂ∑•‰ΩúË°®Âêç‚â§31Ôºâ
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(data);
      // ÂàóÂÆΩÔºönum(8), group(20), genes(14)
      ws['!cols'] = [{ wch: 8 }, { wch: 20 }, ...geneOrder.map(() => ({ wch: 14 }))];

      const ref = ws['!ref'];
      if (ref) {
        const range = XLSX.utils.decode_range(ref);
        // Ë°®Â§¥Âä†Á≤óÔºàÊ†∑ÂºèÊîØÊåÅ‰æùËµñExcelÁâàÊú¨Ôºâ
        for (let c = 0; c <= range.e.c; c++) {
          const addr = XLSX.utils.encode_cell({ r: 0, c });
          if (ws[addr]) ws[addr].s = Object.assign({}, ws[addr].s || {}, { font: { bold: true } });
        }
        // ÊâÄÊúâÂçïÂÖÉÊ†ºÂ∑¶ÂØπÈΩê
        for (let r = 0; r <= range.e.r; r++) {
          for (let c = 0; c <= range.e.c; c++) {
            const addr = XLSX.utils.encode_cell({ r, c });
            if (ws[addr]) {
              ws[addr].s = Object.assign({}, ws[addr].s || {}, { alignment: { horizontal: 'left' } });
            }
          }
        }
        // Êï∞ÂÄºÊ†ºÂºè‰∏∫0.00ÔºàË∑≥ËøánumÂíågroup‰∏§ÂàóÔºâ
        for (let r = 1; r <= range.e.r; r++) {
          for (let c = 2; c <= range.e.c; c++) {
            const addr = XLSX.utils.encode_cell({ r, c });
            const cell = ws[addr];
            if (!cell) continue;
            const num = typeof cell.v === 'number' ? cell.v : parseFloat(String(cell.v));
            if (Number.isFinite(num)) {
              cell.v = num;
              cell.t = 'n';
              cell.z = '0.00';
            }
          }
        }
      }

      const inst = document.getElementById('instrument').value;
      const instLabel = inst === 'roche' ? 'Roche' : 'BioRad';
      let wsName = `PlateExport_${instLabel}`;
      wsName = wsName.slice(0, 31); 
      XLSX.utils.book_append_sheet(wb, ws, wsName);

      const summaryHeader = ['group name','gene','N','Missing','Mean','StdDev'];
      const summaryData = [summaryHeader];
      for (const [group, gmap] of groupMap.entries()) {
        geneOrder.forEach(g => {
          const arr = gmap.get(g) || [];
          const nums = arr
            .map(v => (typeof v === 'number' ? v : parseFloat(String(v))))
            .filter(v => Number.isFinite(v));
          const N = nums.length;
          const Missing = arr.length - N;
          let Mean = '';
          let Std = '';
          if (N > 0) {
            const sum = nums.reduce((a,b) => a + b, 0);
            Mean = sum / N;
            if (N > 1) {
              const mean = Mean;
              const variance = nums.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / (N - 1);
              Std = Math.sqrt(variance);
            }
          }
          summaryData.push([group, g, N, Missing, Mean, Std]);
        });
      }
      const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
      wsSummary['!cols'] = [
        { wch: 20 }, // group
        { wch: 14 }, // gene
        { wch: 6 },  // N
        { wch: 8 },  // Missing
        { wch: 10 }, // Mean
        { wch: 10 }  // StdDev
      ];
      const sref = wsSummary['!ref'];
      if (sref) {
        const sr = XLSX.utils.decode_range(sref);
        for (let c = 0; c <= sr.e.c; c++) {
          const addr = XLSX.utils.encode_cell({ r: 0, c });
          if (wsSummary[addr]) wsSummary[addr].s = Object.assign({}, wsSummary[addr].s || {}, { font: { bold: true } });
        }
        // Ë°å1ÂºÄÂßãÊòØÊï∞ÊçÆË°åÔºöN/MissingËÆæ‰∏∫Êï∞Â≠óÔºõMean/StdDevËÆæ‰∏∫Êï∞Â≠óÂπ∂Ê†ºÂºè0.00
        for (let r = 1; r <= sr.e.r; r++) {
          // N
          const nAddr = XLSX.utils.encode_cell({ r, c: 2 });
          if (wsSummary[nAddr] && Number.isFinite(parseFloat(String(wsSummary[nAddr].v)))) {
            wsSummary[nAddr].v = parseInt(String(wsSummary[nAddr].v), 10);
            wsSummary[nAddr].t = 'n';
            wsSummary[nAddr].z = '0';
          }
          // Missing
          const mAddr = XLSX.utils.encode_cell({ r, c: 3 });
          if (wsSummary[mAddr] && Number.isFinite(parseFloat(String(wsSummary[mAddr].v)))) {
            wsSummary[mAddr].v = parseInt(String(wsSummary[mAddr].v), 10);
            wsSummary[mAddr].t = 'n';
            wsSummary[mAddr].z = '0';
          }
          // Mean
          const meanAddr = XLSX.utils.encode_cell({ r, c: 4 });
          if (wsSummary[meanAddr] && Number.isFinite(parseFloat(String(wsSummary[meanAddr].v)))) {
            const num = parseFloat(String(wsSummary[meanAddr].v));
            wsSummary[meanAddr].v = num;
            wsSummary[meanAddr].t = 'n';
            wsSummary[meanAddr].z = '0.00';
          }
          // StdDev
          const stdAddr = XLSX.utils.encode_cell({ r, c: 5 });
          if (wsSummary[stdAddr] && Number.isFinite(parseFloat(String(wsSummary[stdAddr].v)))) {
            const num = parseFloat(String(wsSummary[stdAddr].v));
            wsSummary[stdAddr].v = num;
            wsSummary[stdAddr].t = 'n';
            wsSummary[stdAddr].z = '0.00';
          }
        }
      }
      let wsName2 = 'Summary';
      wsName2 = wsName2.slice(0, 31);
      XLSX.utils.book_append_sheet(wb, wsSummary, wsName2);

      let fname = document.getElementById('xlsxFileName').value.trim();
      if (!fname) {
        const importedName = getImportedFileName();
        if (importedName) {
          fname = `${importedName}_trans.xlsx`;
        } else {
          const now = new Date();
          const ds = now.toISOString().slice(0,10);
          const ts = now.toTimeString().slice(0,5).replace(':','-');
          const inst2 = document.getElementById('instrument').value;
          const instLabel2 = inst2 === 'roche' ? 'Roche' : 'BioRad';
          fname = `PlateExport_${instLabel2}_${ds}_${ts}.xlsx`;
        }
      } else if (!fname.endsWith('.xlsx')) {
        fname += '.xlsx';
      }
      XLSX.writeFile(wb, fname);

      // ÂØºÂá∫ÂΩìÂâçÂ≠îÊùøËßÜÂõæÊà™ÂõæÔºàPNGÔºâ
      downloadPlateScreenshot(fname);
    }

    // ÂØºÂá∫Â≠îÊùøËßÜÂõæ‰∏∫PNG
    function downloadPlateScreenshot(baseName) {
      const node = document.getElementById('stageWrap');
      const inst = document.getElementById('instrument').value;
      const instLabel = inst === 'roche' ? 'Roche' : 'BioRad';
      const pngName = baseName && baseName.endsWith('.xlsx')
        ? baseName.replace('.xlsx', `_${instLabel}_plate.png`)
        : `PlateExport_${instLabel}_plate.png`;
      html2canvas(node, { backgroundColor: '#ffffff', scale: 2 }).then(canvas => {
        canvas.toBlob(blob => {
          const a = document.createElement('a');
          const url = URL.createObjectURL(blob);
          a.href = url;
          a.download = pngName;
          a.click();
          URL.revokeObjectURL(url);
        });
      });
    }

    // Zoom & Pan
    const stage = document.getElementById('stage');
    const stageWrap = document.getElementById('stageWrap');
    const zoomRange = document.getElementById('zoomRange');
    const viewStatus = document.getElementById('viewStatus');
    let scale = 1;
    let tx = 0, ty = 0;
    let panning = false;
    let panStart = {x:0,y:0};
    let viewStart = {x:0,y:0};

    // Â±Ö‰∏≠ÁΩëÊ†ºÊòæÁ§∫
    function centerPlate() {
      // ‰ª•Êú™Áº©ÊîæÂâçÁöÑÁΩëÊ†ºÂÆΩÈ´ò‰º∞ÁÆóÂ±Ö‰∏≠‰ΩçÁΩÆ
      const gridNode = document.getElementById('grid');
      const wrapRect = stageWrap.getBoundingClientRect();
      const gridRect = gridNode.getBoundingClientRect();
      // gridRect ÊòØÂΩìÂâçÂèòÊç¢ÂêéÁöÑÂ∞∫ÂØ∏ÔºåÂèçÁÆóÂéüÂßãÂ∞∫ÂØ∏
      const gridW = gridRect.width / scale;
      const gridH = gridRect.height / scale;
      tx = Math.round((wrapRect.width - gridW) / 2);
      ty = Math.round((wrapRect.height - gridH) / 2);
      applyTransform();
    }

    function applyTransform() {
      stage.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
      viewStatus.textContent = `scale:${scale.toFixed(2)}, x:${Math.round(tx)}, y:${Math.round(ty)}`;
    }

    stageWrap.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = stage.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const delta = -Math.sign(e.deltaY) * 0.05; // up->zoom in
      const newScale = Math.min(2, Math.max(0.5, scale + delta));

      // ‰ª•Èº†Ê†á‰∏∫Ëøë‰ºº‰∏≠ÂøÉÁº©ÊîæÔºöË∞ÉÊï¥Âπ≥Áßª‰øùÊåÅÁÑ¶ÁÇπ‰ΩçÁΩÆÁõ∏ÂØπÁ®≥ÂÆö
      const k = newScale / scale;
      tx = mx - k * mx + k * tx;
      ty = my - k * my + k * ty;
      scale = newScale;
      zoomRange.value = scale.toFixed(2);
      applyTransform();
    }, { passive:false });

    // Pan when holding Space or middle button
    stageWrap.addEventListener('mousedown', (e) => {
      if (e.button === 1 || e.buttons === 4 || spacePressed) {
        e.preventDefault();
        panning = true;
        panStart = { x: e.clientX, y: e.clientY };
        viewStart = { x: tx, y: ty };
      }
    });
    window.addEventListener('mousemove', (e) => {
      if (!panning) return;
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;
      tx = viewStart.x + dx;
      ty = viewStart.y + dy;
      applyTransform();
    });
    window.addEventListener('mouseup', () => { panning = false; });
    let spacePressed = false;
    window.addEventListener('keydown', (e) => { if (e.code === 'Space') spacePressed = true; });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') spacePressed = false; });

    zoomRange.addEventListener('input', () => {
      const newScale = parseFloat(zoomRange.value);
      // Áº©Êîæ‰∏≠ÂøÉÁî®ËßÜÂè£‰∏≠ÂøÉ
      const rect = stageWrap.getBoundingClientRect();
      const mx = rect.width/2;
      const my = rect.height/2;
      const k = newScale / scale;
      tx = mx - k * mx + k * tx;
      ty = my - k * my + k * ty;
      scale = newScale;
      applyTransform();
    });
    document.getElementById('resetView').addEventListener('click', () => {
      scale = 1;
      zoomRange.value = '1';
      centerPlate();
    });

    // Wire buttons
    document.getElementById('applyBtn').addEventListener('click', applyValues);
    document.getElementById('removeSelBtn').addEventListener('click', removeSelections);
    document.getElementById('clearSampleBtn').addEventListener('click', clearSelectedSampleNames);
    document.getElementById('clearGeneBtn').addEventListener('click', clearSelectedTargetGenes);
    document.getElementById('clearValuesBtn').addEventListener('click', clearSelectedValues);
    document.getElementById('resetAllBtn').addEventListener('click', resetAll);

    document.getElementById('exportXLSXBtn').addEventListener('click', generateXLSX);

    // Enter ÈîÆËß¶Âèë ApplyÔºà‰ªÖÂú®Êó†‰øÆÈ•∞ÈîÆ‰∏îÂ≠òÂú®ÈÄâ‰∏≠ÂçïÂÖÉÊ†ºÊó∂Ôºâ
    function handleEnterApply(e) {
      if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
        const selected = document.querySelectorAll('#grid td.selected');
        if (selected.length > 0) {
          e.preventDefault();
          applyValues();
        }
      }
    }
    // Âú®‰∏§‰∏™ËæìÂÖ•Ê°ÜÈáåÊåâ Enter Ëß¶Âèë
    document.getElementById('sampleName').addEventListener('keydown', handleEnterApply);
    document.getElementById('targetGene').addEventListener('keydown', handleEnterApply);
    // Âú®‰æßÊ†èÂÖ∂ÂÆÉÂå∫ÂüüÊåâ Enter ‰πüÂèØËß¶ÂèëÔºàÈÅøÂÖçÂú®Êñá‰ª∂ËæìÂÖ•ÊàñÊåâÈíÆ‰∏äËß¶ÂèëÔºâ
    document.querySelector('.sidebar').addEventListener('keydown', (e) => {
      const tag = e.target.tagName.toLowerCase();
      if (tag === 'input' || tag === 'select' || tag === 'textarea') return; // Â∑≤Áî±‰∏ìÁî®ÁõëÂê¨Â§ÑÁêÜ
      handleEnterApply(e);
    });

    // Excel ÂØºÂÖ•
    // Web WorkerÔºöÂú®ÂêéÂè∞Ëß£ÊûêExcelÔºå‰∏ªÁ∫øÁ®ã‰ªÖË¥üË¥£Ê∏≤Êüì‰∏éUI
    let excelWorker = null;
    function initExcelWorker() {
      const workerCode = `
self.importScripts('https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js');
function readRowsWithHeader(ws, required) {
  const a2 = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });
  let headerIdx = -1;
  let header = null;
  for (let i = 0; i < a2.length; i++) {
    const row = a2[i].map(v => String(v).trim());
    const lower = row.map(v => v.toLowerCase());
    const ok = required.every(key => lower.includes(key.toLowerCase()));
    if (ok) { headerIdx = i; header = row; break; }
  }
  if (headerIdx === -1) return [];
  const rows = [];
  for (let i = headerIdx + 1; i < a2.length; i++) {
    const r = a2[i];
    if (!r || r.length === 0) continue;
    const obj = {};
    header.forEach((h, idx) => { obj[String(h).trim()] = r[idx]; });
    rows.push(obj);
  }
  return rows;
}
function getVal(obj, names) {
  for (const n of names) {
    const k = Object.keys(obj).find(key => key.toLowerCase() === n.toLowerCase());
    if (k) return obj[k];
  }
  return '';
}
self.onmessage = function(e) {
  const { buffer } = e.data;
  let detected = null;
  let imported = 0;
  const wb = XLSX.read(buffer, { type: 'array' });
  const results = [];
  for (const sheetName of wb.SheetNames) {
    const ws = wb.Sheets[sheetName];
    // Try Bio-Rad
    let rows = readRowsWithHeader(ws, ['Well','Target','Sample','Cq']);
    if (rows.length > 0) {
      detected = 'biorad';
      for (const row of rows) {
        const well = getVal(row, ['Well']);
        const target = getVal(row, ['Target']);
        const sample = getVal(row, ['Sample']);
        const cq = getVal(row, ['Cq']);
        results.push({ pos: well, sample, gene: target, ct: cq });
        imported++;
      }
      continue;
    }
    // Try Roche
    rows = readRowsWithHeader(ws, ['Pos','Name','Cp']);
    if (rows.length > 0) {
      detected = detected || 'roche';
      for (const row of rows) {
        const pos = getVal(row, ['Pos']);
        const name = getVal(row, ['Name']);
        const cp = getVal(row, ['Cp']);
        results.push({ pos, sample: name, gene: pos, ct: cp });
        imported++;
      }
      continue;
    }
  }
  self.postMessage({ detected, imported, results });
};
`;
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      excelWorker = new Worker(url);
    }
    function normalizePos(pos) {
      if (!pos) return null;
      const m = String(pos).trim().toUpperCase().match(/^([A-P])0*([1-9]|1[0-9]|2[0-4])$/);
      if (!m) return null;
      return m[1] + String(parseInt(m[2], 10));
    }
    function setCellByPos(pos, sample, gene, ct) {
      const norm = normalizePos(pos);
      if (!norm) return false;
      const row = norm[0];
      const col = parseInt(norm.slice(1), 10);
      const td = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
      if (!td) return false;
      if (sample !== undefined) td.dataset.sampleName = sample || '';
      if (gene !== undefined) td.dataset.targetGene = gene || '';
      if (ct !== undefined) td.dataset.ct = ct !== '' && ct !== null && ct !== undefined ? String(ct) : '';
      updateCellAppearance(td);
      return true;
    }
    function readRowsWithHeader(ws, required) {
      // ‰ª• header:1 ËØªÂèñ‰∫åÁª¥Êï∞ÁªÑÔºåÊü•ÊâæÂåÖÂê´ÊâÄÈúÄÂàóÁöÑË°®Â§¥Ë°å
      const a2 = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });
      let headerIdx = -1;
      let header = null;
      for (let i = 0; i < a2.length; i++) {
        const row = a2[i].map(v => String(v).trim());
        const lower = row.map(v => v.toLowerCase());
        const ok = required.every(key => lower.includes(key.toLowerCase()));
        if (ok) { headerIdx = i; header = row; break; }
      }
      if (headerIdx === -1) return [];
      const rows = [];
      for (let i = headerIdx + 1; i < a2.length; i++) {
        const r = a2[i];
        if (!r || r.length === 0) continue;
        const obj = {};
        header.forEach((h, idx) => { obj[String(h).trim()] = r[idx]; });
        rows.push(obj);
      }
      return rows;
    }
    function getVal(obj, names) {
      for (const n of names) {
        const k = Object.keys(obj).find(key => key.toLowerCase() === n.toLowerCase());
        if (k) return obj[k];
      }
      return '';
    }
    async function importExcelFile(file) {
      const buf = await file.arrayBuffer();
      if (!excelWorker) initExcelWorker();
      return new Promise((resolve) => {
        excelWorker.onmessage = (e) => {
          const { detected, imported, results } = e.data || {};
          let countSet = 0;
          if (Array.isArray(results)) {
            results.forEach(({ pos, sample, gene, ct }) => {
              if (setCellByPos(pos, sample, gene, ct)) countSet++;
            });
          }
          if (!detected || imported === 0 || countSet === 0) {
            alert('No valid Bio-Rad or Roche data headers detected, please check Excel file format.');
            resolve({ detected: null, imported: 0 });
            return;
          }
          const instSel = document.getElementById('instrument');
          if (detected === 'biorad') instSel.value = 'biorad';
          else if (detected === 'roche') instSel.value = 'roche';
          alert(`Import completed: ${detected === 'biorad' ? 'Bio-Rad' : 'Roche'} data, ${countSet} wells updated.`);
          resolve({ detected, imported: countSet });
        };
        // Â∞ÜArrayBufferËΩ¨ÁßªÂà∞WorkerÔºåÈÅøÂÖçÂ§çÂà∂
        excelWorker.postMessage({ buffer: buf }, [buf]);
      });
    }

    // Êñá‰ª∂ÈÄâÊã©ÂêéËá™Âä®ÂØºÂÖ•Êï∞ÊçÆ
    document.getElementById('excelFile').addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      
      // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
      const fileInput = document.getElementById('excelFile');
      fileInput.disabled = true;
      fileInput.style.opacity = '0.7';
      
      // Ê∏ÖÁ©∫ÂΩìÂâçÊï∞ÊçÆ
      document.querySelectorAll('#grid td').forEach(td => {
        td.classList.remove('selected','only-sample','only-gene','both-values');
        td.dataset.sampleName = ''; td.dataset.targetGene = ''; td.dataset.ct = '';
        td.title=''; td.innerHTML='';
      });
      
      try {
        await importExcelFile(file);
        updateSidebarInputs();
        
        // ÂØºÂÖ•ÊàêÂäüÂêéÊ∏ÖÁ©∫Êñá‰ª∂ÈÄâÊã©ÔºåÂÖÅËÆ∏ÈáçÊñ∞ÈÄâÊã©
        e.target.value = '';
        
        // ÊÅ¢Â§çÊñá‰ª∂ËæìÂÖ•Áä∂ÊÄÅ
        fileInput.disabled = false;
        fileInput.style.opacity = '1';
        
      } catch (error) {
        console.error('ÂØºÂÖ•Â§±Ë¥•:', error);
        alert('File import failed, please check if the file format is correct.');
        
        // ÊÅ¢Â§çÊñá‰ª∂ËæìÂÖ•Áä∂ÊÄÅ
        fileInput.disabled = false;
        fileInput.style.opacity = '1';
      }
    });

    // Init
    createGrid();
    // Initialize cell dataset
    document.querySelectorAll('#grid td').forEach(td => { td.dataset.sampleName=''; td.dataset.targetGene=''; td.dataset.ct=''; });
    // ÂàùÂßãÂ±Ö‰∏≠
    centerPlate();
    // Á™óÂè£Â∞∫ÂØ∏ÂèòÂåñÊó∂‰øùÊåÅÂ±Ö‰∏≠
    window.addEventListener('resize', () => { centerPlate(); });
  </script>
</body>
</html>

<!--  Designed by Guanghan Fan & Tecent Codebuddy